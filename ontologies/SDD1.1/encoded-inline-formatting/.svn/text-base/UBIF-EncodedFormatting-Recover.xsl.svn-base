<?xml version="1.0" encoding="iso-8859-1"?>
<?xmlspysamplexml UBIF-EncodedFormatting-SampleData.xml?>
<xsl:stylesheet version="1.0" 
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
 xmlns="http://www.w3.org/1999/xhtml">
 <xsl:variable name="GeneratorCopyright" select="'DiversityDescriptionTools Version 0.4. Copyright (c) G. Hagedorn 2004.'"/>
<!-- Proof of concept example code showing how encoded UBIF text formatting can be recovered. Please refer to the associated documentation for additional information. You may want to try the transformation with the xsl-RecoverEncodedFormattingTest.xml example file. The expected output is provided in xsl-RecoverEncodedFormattingOutput.html -->

  <xsl:output method="xml" indent="no"
   encoding="iso-8859-1"
   doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN" 
   doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"/>

  <!-- overwrite the built-in template which otherwise outputs any element/attribute content: -->
  <xsl:template match="text()|@*"/>

  <xsl:template match="root">  
    <html>
      <head>
        <title>Testing "recover encoded formatting" xslt code</title>
        <meta http-equiv="content-type" content="text/html; charset=iso-8859-1"/>
        <link href="/Workbench02.CSS" type="text/css" rel="stylesheet"/> 
      </head>
      <body lang="en-us">
        <xsl:apply-templates/>
        <p>(Generated by <xsl:value-of select="$GeneratorCopyright"/><!-- in xslt 2.0 also add current date... -->)</p>
      </body>
    </html>
  </xsl:template>

  <xsl:template match="Text">
    <p><xsl:call-template name="RecoverEncodedFormatting"><xsl:with-param name="string" select="./text()"/></xsl:call-template></p>
  </xsl:template>

<xsl:template name="RecoverEncodedFormatting">
  <!-- 	replace a few encoded xhtml-markup-like character formatting with real xhtml elements 
    This works when the encoded opening tag contain redundant blanks (like "<em >"), but not when it contains attributes! The closing tag may not contain blanks. The script does handle different tags nested and multiple occurrences ( e.g. "x <em>y<sup>2</sup></em>  <em>z</em>"). It does not handle the same tag nested. In this case it will, however, still produce valid balanced xml, which was considered most important. -->  
  <xsl:param name="string" select="''"/>
  <xsl:variable name="temp" select="substring-after($string, '&lt;')"/><!-- text after start of first tag in string -->
  <xsl:variable name="tt"   select="substring-before($temp, '&gt;')"/><!-- tag text (don't normalize, may be needed unchanged if not recognized) -->
  <xsl:variable name="ta"   select="substring-after($temp, '&gt;')"/><!-- text after tag, may be empty -->
  <xsl:choose>
    <xsl:when test="string-length($tt) = 0"><!-- no more text between &lt; and &gt; found i.e. end recursion -->
      <xsl:value-of select="$string"/>
    </xsl:when>
    <xsl:otherwise>
        <xsl:variable name="tn"   select="normalize-space($tt)"/><!-- normalized (= trimmed) tag text -->
        <xsl:variable name="tclose"   select="concat('&lt;/', $tn, '&gt;')"/><!-- closing tag-->
        <xsl:value-of select="substring-before($string, '&lt;')"/><!-- output text-before opening &lt;, may be empty-->
        <xsl:choose><!-- ### The following are the accepted non-empty xhtml tags! -->
          <xsl:when test="($tn='sup' or $tn='sub' or $tn='em' or $tn='i' or $tn='b' or $tn='strong') and contains($ta, $tclose)">
            <xsl:element name="{$tn}" namespace="http://www.w3.org/1999/xhtml" ><!-- recurse into text before closing tag = formatted content -->
               <xsl:call-template name="RecoverEncodedFormatting"><xsl:with-param name="string" select="substring-before($ta, $tclose)"/></xsl:call-template>
            </xsl:element><!-- Next: recurse into text after closing tag: -->
            <xsl:call-template name="RecoverEncodedFormatting"><xsl:with-param name="string" select="substring-after($temp, $tclose)"/></xsl:call-template>
          </xsl:when><!-- ### The following are the accepted empty html tags! br is also accepted as html (no slash) -->
          <xsl:when test="$tn='br' or $tn='br/' or $tn='br /'">
            <xsl:element name="br" namespace="http://www.w3.org/1999/xhtml" />
            <xsl:call-template name="RecoverEncodedFormatting"><xsl:with-param name="string" select="$ta"/></xsl:call-template>
          </xsl:when>
          <xsl:otherwise><!-- tag not recognized, restore tag itself and recurse with text-after (ta) -->
            <xsl:value-of select="concat('&lt;', $tt, '&gt;')"/>
            <xsl:call-template name="RecoverEncodedFormatting"><xsl:with-param name="string" select="$ta"/></xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

</xsl:stylesheet>