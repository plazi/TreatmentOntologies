<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>SDD_TypeLib.xsd schema file overview</title><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="/Workbench02.CSS" type="text/css" rel="stylesheet"/><link href="/Workbench02p.CSS" type="text/css" rel="stylesheet" media="print"/></head><body lang="en-us"><h1>SDD_TypeLib.xsd schema file overview</h1><p class="compact"><strong>(Version: Unified Biosciences Information Framework (UBIF) 1.1 and SDD 1.1)</strong></p><p class="signature"><a href="http://www.tdwg.org" class="invis">TDWG</a> working group: <a href="http://wiki.tdwg.org/twiki/bin/view/SDD" class="invis">Structure of Descriptive Data (SDD)</a></p><h2>Introduction</h2><p>This document gives an overview of the schema components present in a single schema file, similar to the entry view provided by graphical schema editors. It documents only the root level annotations and components (elements, global attributes, simple and complex types, and groups). The definition of the components listed here is documented separately (hyperlinking could not yet be implemented).</p><p>Because the UBIF schema is designed as a type library, complex types represent class definitions and most schema files contain only a single root-level element.</p><p>Please see the <a href="rddl.html">schema documentation resource directory</a> for schema overviews of other files and detailed component documentation.</p><hr/><h2>Schema file content</h2><p>The following content is generated automatically from the documentation inside the schema file:</p><p>This file will be included into the UBIF/SDD integration schema 'SDD.xsd' (SDD uses the same namespace as UBIF).</p><p>Copyright Â© 2006 TDWG (Taxonomic Databases Working Group, www.tdwg.org). See the file SDD_(c).xsd for authorship and licensing information.</p><p>Due to problems with key/keyrefs when using two namespaces (see documentation on the SDD WIKI: http://wiki.tdwg.org/twiki/bin/view/SDD/UBIFDesignRequirements), the SDD schema is based on the UBIF namespace, and thus uses include rather than import!</p><p><strong>Includes: </strong>UBIF_CoreExtensions.xsd</p><p><strong>Includes: </strong>SDD_EnumLib.xsd</p><hr/><p><strong>UBIF insertion groups</strong></p><p>The two SDD-groups are used inside the UBIF top-level Datasets/Dataset structure to define the object collections used by SDD</p><ul class="compact" compact="compact"><li><strong><a name="SDD-DescriptiveTerminology" id="SDD-DescriptiveTerminology">SDD-DescriptiveTerminology</a></strong> (<em>Element group</em>): Defines the operational terminology (concepts, characters, states, etc.)
in which descriptions are expressed.</li><li><strong><a name="SDD-DescriptiveData" id="SDD-DescriptiveData">SDD-DescriptiveData</a></strong> (<em>Element group</em>): Describes individuals (specimens) or classes (taxa) using the terms defined in the operational terminology (concepts, characters, states, etc.).</li></ul><hr/><p><strong>For all first-class objects in SDD, collections of type set are defined. These form root-level collections in the Dataset object.</strong></p><ul class="compact" compact="compact"><li><strong><a name="DescriptiveConceptSet" id="DescriptiveConceptSet">DescriptiveConceptSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension)</li><li><strong><a name="CharacterSet" id="CharacterSet">CharacterSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension)</li><li><strong><a name="CharacterTreeSet" id="CharacterTreeSet">CharacterTreeSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension)</li><li><strong><a name="NaturalLanguageDescriptionSet" id="NaturalLanguageDescriptionSet">NaturalLanguageDescriptionSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension)</li><li><strong><a name="CodedDescriptionSet" id="CodedDescriptionSet">CodedDescriptionSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension)</li><li><strong><a name="IdentificationKeySet" id="IdentificationKeySet">IdentificationKeySet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension)</li></ul><hr/><p><strong>TERMINOLOGY START</strong></p><p>DescriptiveConcepts, Characters and dependent objects (states, modifiers, statistical measures)</p><p>1. a) DescriptiveConcept definitions. Note: relations between concepts may be defined in the operational character tree. Independent ontologies of concepts may be created through Link rel=Subclass etc. Another plan for the future is to allow defining concepts relations inside characters.</p><ul class="compact" compact="compact"><li><strong><a name="DescriptiveConcept" id="DescriptiveConcept">DescriptiveConcept</a></strong> (<em>Complex type</em>, based on <em>VersionedAbstractObject</em> by extension): DescriptiveConcepts may be basic
properties (color, shape,
texture), structural types
(fruit types), methods
(naked eye, hand lens,
microscope) or other
hierarchical generalizations that can be applied to characters
(e. g., relative region: tip
versus base of structure)

Note that a number of ontological relations between concepts may be expressed using the general link structure of the base type (subclass, part of, etc.).</li><li><strong><a name="DescriptiveConceptRef" id="DescriptiveConceptRef">DescriptiveConceptRef</a></strong> (<em>Complex type</em>, based on <em>AbstractLocalRef</em> by extension): Refers to a concept node</li><li><strong><a name="DescriptiveConceptRefSeq" id="DescriptiveConceptRefSeq">DescriptiveConceptRefSeq</a></strong> (<em>Complex type</em>, based on <em>Seq</em> by extension): (A sequence of references to a descriptive concepts)</li></ul><p>Inner classes of DescriptiveConcept. ModifierSeq, ConceptStateSeq, and RecommendedMeasureSeq are second-class objects embedded in first class objects.</p><ul class="compact" compact="compact"><li><strong><a name="DependencyRules" id="DependencyRules">DependencyRules</a></strong> (<em>Complex type</em>)</li><li><strong><a name="ModifierSeq" id="ModifierSeq">ModifierSeq</a></strong> (<em>Complex type</em>, based on <em>Seq</em> by extension)</li><li><strong><a name="ConceptStateSeq" id="ConceptStateSeq">ConceptStateSeq</a></strong> (<em>Complex type</em>, based on <em>Seq</em> by extension)</li><li><strong><a name="RecommendedMeasureSeq" id="RecommendedMeasureSeq">RecommendedMeasureSeq</a></strong> (<em>Complex type</em>, based on <em>Seq</em> by extension)</li></ul><p>1. b) Character tree definitions, references (plus internal types)</p><ul class="compact" compact="compact"><li><strong><a name="CharacterTree" id="CharacterTree">CharacterTree</a></strong> (<em>Complex type</em>, based on <em>VersionedAbstractObject</em> by extension): Defines an entire character tree
(which may be a tree or a single tree node containing a flat list)</li><li><strong><a name="CharTree_NodeRef" id="CharTree_NodeRef">CharTree_NodeRef</a></strong> (<em>Complex type</em>, based on <em>AbstractLocalRef</em> by extension): Refers to a node in the character tree</li><li><strong><a name="CharTree_Node" id="CharTree_Node">CharTree_Node</a></strong> (<em>Complex type</em>): Inner nodes (or terminal nodes if no characters follow)</li><li><strong><a name="CharTree_NodeSeq" id="CharTree_NodeSeq">CharTree_NodeSeq</a></strong> (<em>Complex type</em>, based on <em>Seq</em> by extension)</li><li><strong><a name="CharTree_Character" id="CharTree_Character">CharTree_Character</a></strong> (<em>Complex type</em>, based on <a href="#CharacterRef">CharacterRef</a> by extension): A character reference, creating a terminal tree node</li></ul><p>Inner classes of CharacterTree and CharTree_Node:</p><ul class="compact" compact="compact"><li><strong><a name="CharTree_DesignedForSet" id="CharTree_DesignedForSet">CharTree_DesignedForSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension)</li><li><strong><a name="CharTree_InheritableDefs" id="CharTree_InheritableDefs">CharTree_InheritableDefs</a></strong> (<em>Complex type</em>)</li></ul><p>2. --- Character definitions (characters = data recording and analysis variables, depending on observed part, property, and observation or measurement methodology)</p><p>a) Abstract base type and derived types to be used in instance documents.</p><ul class="compact" compact="compact"><li><strong><a name="AbstractCharacterDefinition" id="AbstractCharacterDefinition">AbstractCharacterDefinition</a></strong> (<em>Abstract Complex type</em>, based on <em>VersionedAbstractObject</em> by extension): Defines a character in the 
terminology. Abstract base 
type, one of the 
extensions below must 
be used in instance 
documents</li><li><strong><a name="CategoricalCharacter" id="CategoricalCharacter">CategoricalCharacter</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharacterDefinition">AbstractCharacterDefinition</a> by extension): # Derived from AbstractCharacterDefinition to be used in instance documents (non-abstract type).

Categorical data include nominal and ordinal data (DELTA types UM/OM and NEXUS types). Other terms for categorical data in statistics are 'qualitative data' or 'attributes'. The term 'attribute' has been avoided in SDD because it has different definitions in statistics, programming, databases, DELTA, etc. Both 'qualitative' and 'attribute' are ambiguos as to whether ordinal/ ranked variables are in- or excluded.</li><li><strong><a name="QuantitativeCharacter" id="QuantitativeCharacter">QuantitativeCharacter</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharacterDefinition">AbstractCharacterDefinition</a> by extension): # Derived from AbstractCharacterDefinition to be used in instance documents (non-abstract type)

Quantitative data include data like the DELTA types IN/RN. They are not supported by NEXUS.</li><li><strong><a name="MolecularSequenceCharacter" id="MolecularSequenceCharacter">MolecularSequenceCharacter</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharacterDefinition">AbstractCharacterDefinition</a> by extension): # Derived from AbstractCharacterDefinition to be used in instance documents (non-abstract type)</li><li><strong><a name="TextCharacter" id="TextCharacter">TextCharacter</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharacterDefinition">AbstractCharacterDefinition</a> by extension): # Derived from AbstractCharacterDefinition to be used in instance documents (non-abstract type). In coded descriptions, these characters only support a Text element for unconstrained text.

For applications not capable to analyze unconstrained natural language, text data can not be used in identification.</li></ul><p>Note: The ColorRangeCharacter above is only an example of other derivations expected, like algorithmically described shapes, molecular sequences (genome/proteome), or molecular patterns (RFLP, AFLP, etc)</p><p>b) inner classes, one-time use within character definitions above</p><ul class="compact" compact="compact"><li><strong><a name="CategoricalCharMapping" id="CategoricalCharMapping">CategoricalCharMapping</a></strong> (<em>Complex type</em>): Inner class, used only within CategoricalCharacter</li><li><strong><a name="CategoricalCharMappingSet" id="CategoricalCharMappingSet">CategoricalCharMappingSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension): Inner class, used only within CategoricalCharacter</li><li><strong><a name="CategoricalCharAssumptions" id="CategoricalCharAssumptions">CategoricalCharAssumptions</a></strong> (<em>Complex type</em>): Inner class, used only within CategoricalCharacter</li><li><strong><a name="QuantitativeCharMapping" id="QuantitativeCharMapping">QuantitativeCharMapping</a></strong> (<em>Complex type</em>): Inner class, used only within QuantitativeCharacter</li><li><strong><a name="QuantitativeCharMappingSet" id="QuantitativeCharMappingSet">QuantitativeCharMappingSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension): Inner class, used only within QuantitativeCharacter</li><li><strong><a name="QuantitativeCharAssumptions" id="QuantitativeCharAssumptions">QuantitativeCharAssumptions</a></strong> (<em>Complex type</em>): Inner class, used only within QuantitativeCharacter</li><li><strong><a name="QuantitativeCharDefaults" id="QuantitativeCharDefaults">QuantitativeCharDefaults</a></strong> (<em>Complex type</em>): Inner class, used only within QuantitativeCharacter</li></ul><p>c) State definitions within CategoricalCharacter. Abstract base type and derived types to be used in instance documents. </p><ul class="compact" compact="compact"><li><strong><a name="CharacterLocalStateDef" id="CharacterLocalStateDef">CharacterLocalStateDef</a></strong> (<em>Complex type</em>, based on <a href="#AbstractVocabularyBase">AbstractVocabularyBase</a> by extension): Currently identical to AbstractVocabularyBase</li><li><strong><a name="ConceptStateDef" id="ConceptStateDef">ConceptStateDef</a></strong> (<em>Complex type</em>, based on <a href="#AbstractVocabularyBase">AbstractVocabularyBase</a> by extension): Currently identical to AbstractVocabularyBase</li><li><strong><a name="CharacterStateSeq" id="CharacterStateSeq">CharacterStateSeq</a></strong> (<em>Complex type</em>, based on <em>Seq</em> by extension)</li></ul><p>d) Character and state references</p><ul class="compact" compact="compact"><li><strong><a name="CharacterRef" id="CharacterRef">CharacterRef</a></strong> (<em>Complex type</em>, based on <em>AbstractLocalRef</em> by extension): Refers to a character (e. g., from within concept trees or from descriptions). It consists only of a reference to a Character definition id.</li><li><strong><a name="CharacterStateRef" id="CharacterStateRef">CharacterStateRef</a></strong> (<em>Complex type</em>, based on <em>AbstractLocalRef</em> by extension): Refers to a character state (e. g., from descriptions). It consists only of a reference to a Character state definition id.</li><li><strong><a name="CharacterStateRefSet" id="CharacterStateRefSet">CharacterStateRefSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension): A collection of state references (CharacterStateRef type)</li><li><strong><a name="ConceptStateRef" id="ConceptStateRef">ConceptStateRef</a></strong> (<em>Complex type</em>, based on <em>AbstractLocalRef</em> by extension): Refers to a project-wide definition of a categorical state at a concept node</li></ul><p>e) Modifiers cover expressions of certainty, frequency, manner, degree, etc. that can be added to existing character value or state data in descriptions.</p><ul class="compact" compact="compact"><li><strong><a name="ModifierDef" id="ModifierDef">ModifierDef</a></strong> (<em>Complex type</em>, based on <a href="#AbstractVocabularyBase">AbstractVocabularyBase</a> by extension): State or character modifier definitions (certainty, frequency, spatial, temporal, etc.)</li></ul><p>Modifier reference (single, and group with multiple) to be used in coded descriptions:</p><ul class="compact" compact="compact"><li><strong><a name="ModifierRefWithData" id="ModifierRefWithData">ModifierRefWithData</a></strong> (<em>Complex type</em>, based on <em>AbstractLocalRef</em> by extension): Actual modification of a statement. Refers to a modifier of any type (frequency, certainty, spatial, temporal, etc.).</li></ul><ul class="compact" compact="compact"><li><strong><a name="ModifierRefWithDataGroup" id="ModifierRefWithDataGroup">ModifierRefWithDataGroup</a></strong> (<em>Element group</em>): Multiple modifier references, optionally with data.</li></ul><p>Modifier reference extended with Text element, used in natural language markup:</p><ul class="compact" compact="compact"><li><strong><a name="ModifierMarkupRef" id="ModifierMarkupRef">ModifierMarkupRef</a></strong> (<em>Complex type</em>, based on <a href="#ModifierRefWithData">ModifierRefWithData</a> by extension): Actual modification of a statement for markup of natural language descriptions (with Text inside). Refers to a modifier of any type (frequency, certainty, spatial, temporal, etc.).</li></ul><p>(Note on ModifierRef/ModifierRefMarkup: Although semantics for the lower/upper attributes are defined only for frequency and certainty modifiers, the schema allows are them in all statement modifications. Additional validation by other means than xml schema may be provided, and applications should use the lower/upper attributes only in modifiers of types than Certainty and Frequency. In other modifier types, the values may be discarded upon import. XML schema validation was attempted in SDD up to 1.0 beta 2, but this resulted in a complex system of multiple derived base types and was considered too complicated.</p><p>f) Statistical measures: The base semantics and labels are already available through UBIF. At concepts node further elaboration may occur: a) wording and value formatting b) definition of recommended measure sets.</p><ul class="compact" compact="compact"><li><strong><a name="UnivarStatMeasureElaboration" id="UnivarStatMeasureElaboration">UnivarStatMeasureElaboration</a></strong> (<em>Complex type</em>, based on <a href="#AbstractVocabularyBase">AbstractVocabularyBase</a> by extension):  A kind of local extension of the base definition of a statistical measure; used inside in concepts, adding, e. g., formatting information.</li><li><strong><a name="ValueRangeWithClass" id="ValueRangeWithClass">ValueRangeWithClass</a></strong> (<em>Complex type</em>, based on <em>ValueRange</em> by extension): ValueRange extended with a specification for the kind of value (broad enumerated statistical concepts).</li></ul><hr/><p><strong>TERMINOLOGY END</strong></p><hr/><p><strong>TERMINOLOGY-BASED DATA</strong></p><p>The following types are used in descriptions or identification key to code descriptive data by reference to characters, states, and modifiers defined in the Terminology.</p><p>3. --- Character references in coded descriptions: SummaryData</p><p>a) abstract and non-abstract derived types used in coded descriptions</p><p>Note: The non-abstract derived types are to be used in instance documents. The type names have been shortened to simplify instance documents, especially if an xsi:type would be used (Char xsi:type='CatSummaryData').</p><ul class="compact" compact="compact"><li><strong><a name="AbstractCharSummaryData" id="AbstractCharSummaryData">AbstractCharSummaryData</a></strong> (<em>Abstract Complex type</em>, based on <a href="#CharacterRef">CharacterRef</a> by extension): Abstract base type. Used in CodedDescription/CodedData/Char to make statements for a single character in a class or specimen.</li><li><strong><a name="CatSummaryData" id="CatSummaryData">CatSummaryData</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharSummaryData">AbstractCharSummaryData</a> by extension): # Derived from AbstractCharSummaryData to be used for categorical (char. state) data in instance documents (non-abstract type) </li><li><strong><a name="QuantSummaryData" id="QuantSummaryData">QuantSummaryData</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharSummaryData">AbstractCharSummaryData</a> by extension): # Derived from AbstractCharSummaryData to be used for numerical (statistical measures) data in instance documents (non-abstract type) </li><li><strong><a name="MolecularSequenceData" id="MolecularSequenceData">MolecularSequenceData</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharSummaryData">AbstractCharSummaryData</a> by extension): # Derived from AbstractCharSummaryData to be used for letter-sequence data (especially nucleotide and protein sequences) </li><li><strong><a name="TextCharData" id="TextCharData">TextCharData</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharSummaryData">AbstractCharSummaryData</a> by extension): # Derived from AbstractCharSummaryData to be used for unconstrained text ("Text-fields")</li></ul><p>b) types used inside the CharSummaryData-derived types</p><ul class="compact" compact="compact"><li><strong><a name="StateData" id="StateData">StateData</a></strong> (<em>Complex type</em>, based on <a href="#CharacterStateRef">CharacterStateRef</a> by extension): A categorical state including frequency, state modifier, and Notes</li><li><strong><a name="DataStatusData" id="DataStatusData">DataStatusData</a></strong> (<em>Complex type</em>, based on <em>DataStatus</em> by extension): Similar to StateData, but for status values like '-' (= inapplicable) or '?' (= data unavailable). It support notes, but no modifiers!</li></ul><p>c) A collection of summary character data, containing a choice of derived character data types (polymorphic structure, choice options are equivalent to use of base type plus xsi:type).</p><ul class="compact" compact="compact"><li><strong><a name="SummaryDataSet" id="SummaryDataSet">SummaryDataSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension): A collection of character summary data elements (all of which are derived from CharSummaryData abstractType</li></ul><p>4. --- Character references in coded descriptions: SampleData</p><p>a) abstract and non-abstract derived types used in sample data</p><ul class="compact" compact="compact"><li><strong><a name="AbstractCharSampleData" id="AbstractCharSampleData">AbstractCharSampleData</a></strong> (<em>Abstract Complex type</em>, based on <a href="#CharacterRef">CharacterRef</a> by extension): Abstract base type. Used in CodedDescription/SampleData/
Sample/SamplingUnit.</li><li><strong><a name="CatSampleData" id="CatSampleData">CatSampleData</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharSampleData">AbstractCharSampleData</a> by extension): # Derived from abstract CharSampleData to be used for categorical (char. state) data in instance documents (non-abstract type) </li><li><strong><a name="QuantSampleData" id="QuantSampleData">QuantSampleData</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharSampleData">AbstractCharSampleData</a> by extension): # Derived from abstract CharSampleData to be used for numerical data in instance documents (non-abstract type) in coded descriptions (Sample/ SamplingUnit). Attribute value (xs: double) is for directly measured/observed values. Not for statistical measures; these cannot occur in sampling units!</li></ul><p>5. --- Character references in coded descriptions: SampleData</p><p>a) abstract and non-abstract derived types used in natural language descriptions. Lacking multiple inheritance mechanisms in xml schema, these Markup versions have been derived independently. They are designed to be closely related to corresponding types in the coded description, however.</p><ul class="compact" compact="compact"><li><strong><a name="AbstractCharacterMarkup" id="AbstractCharacterMarkup">AbstractCharacterMarkup</a></strong> (<em>Abstract Complex type</em>, based on <a href="#CharacterRef">CharacterRef</a> by extension): Abstract base type. Used in NaturalLanguageDescriptions.

Note: although Text and DataStatus scoring is common to all derived types, it can not be defined here. The markup of natural language should follow the original text sequence and type derivation would impose an xml schema sequence constraint.</li><li><strong><a name="CategoricalMarkup" id="CategoricalMarkup">CategoricalMarkup</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharacterMarkup">AbstractCharacterMarkup</a> by extension): # Extends the abstract CharacterMarkup for use with categorical (char. state) data</li><li><strong><a name="QuantitativeMarkup" id="QuantitativeMarkup">QuantitativeMarkup</a></strong> (<em>Complex type</em>, based on <a href="#AbstractCharacterMarkup">AbstractCharacterMarkup</a> by extension): # Extends the abstract CharacterMarkup for use with numerical (statistical measures) data as well as a list of sample measurement values.</li></ul><p>("ColorRangeMarkup" (color polygon measurement data) or "SequenceMarkup" (molecular or other sequences) are not supported at the moment, since the author do not expect to find them in natural language descriptions. If necessary, these types will be added.)</p><p>b) The following NLD type refers to concept nodes and has no corresponding types in SummaryData/SampleData:</p><ul class="compact" compact="compact"><li><strong><a name="MarkupGroup" id="MarkupGroup">MarkupGroup</a></strong> (<em>Element group</em>): Used in ConceptMarkup 
and root of NLD (without 
a ref to concept). (Note: 
Modeling through class 
derivation alone would 
require multiple 
inheritance.)</li></ul><ul class="compact" compact="compact"><li><strong><a name="NaturalLanguageMarkup" id="NaturalLanguageMarkup">NaturalLanguageMarkup</a></strong> (<em>Complex type</em>): The root of natural language markup is identical to ConceptMarkup, except that the concept ref attribute is prohibited.</li><li><strong><a name="ConceptMarkup" id="ConceptMarkup">ConceptMarkup</a></strong> (<em>Complex type</em>, based on <a href="#DescriptiveConceptRef">DescriptiveConceptRef</a> by extension): Used in NaturalLanguageDescriptions. Refers to concepts (i. e. nodes defined in concept trees)</li></ul><p>c) types used inside the CharacterMarkup types</p><ul class="compact" compact="compact"><li><strong><a name="MarkupText" id="MarkupText">MarkupText</a></strong> (<em>Complex type</em>, based on <em>LongString</em> by extension): Formatted text with an additional optional attribute "parsed" (default=false). Used for Text and Note elements inside the NaturalLanguageDescription container.</li><li><strong><a name="DataStatusMarkup" id="DataStatusMarkup">DataStatusMarkup</a></strong> (<em>Complex type</em>, based on <em>DataStatus</em> by extension): Variant of DataStatusData to be used inside the NaturalLanguageDescription markup container.</li><li><strong><a name="StateMarkup" id="StateMarkup">StateMarkup</a></strong> (<em>Complex type</em>, based on <a href="#CharacterStateRef">CharacterStateRef</a> by extension): Variant of StateData to be used inside the NaturalLanguageDescription markup container.</li><li><strong><a name="ValueMarkup" id="ValueMarkup">ValueMarkup</a></strong> (<em>Complex type</em>): For single values (singleton observation or values in a sample).</li><li><strong><a name="MeasureMarkup" id="MeasureMarkup">MeasureMarkup</a></strong> (<em>Complex type</em>, based on <em>UnivarSimpleStatMeasureData</em> by extension): (Used inside Quantitative markup)</li><li><strong><a name="PMeasureMarkup" id="PMeasureMarkup">PMeasureMarkup</a></strong> (<em>Complex type</em>, based on <em>UnivarParamStatMeasureData</em> by extension): (Used inside Quantitative markup)</li></ul><hr/><p><strong>TERMINOLOGY-BASED DATA END</strong></p><hr/><p><strong>DESCRIPTIONS START</strong></p><p>Descriptions are either natural language with optional markup or coded descriptions. Both are derived from the same base type:</p><ul class="compact" compact="compact"><li><strong><a name="AbstractDescription" id="AbstractDescription">AbstractDescription</a></strong> (<em>Abstract Complex type</em>, based on <em>VersionedAbstractObject</em> by extension): Abstract base type for NaturalLanguageDescription
and CodedDescription.

The id attribute is currently not used in keyrefs from within this schema. However, it is considered generally useful to uniquely identify descriptions in federated situations.</li><li><strong><a name="DescriptionScopeSet" id="DescriptionScopeSet">DescriptionScopeSet</a></strong> (<em>Complex type</em>, based on <em>ExtendedScopeSet</em> by extension): Extension of Scope base classes for descriptive concepts</li><li><strong><a name="NaturalLanguageDescription" id="NaturalLanguageDescription">NaturalLanguageDescription</a></strong> (<em>Complex type</em>, based on <a href="#AbstractDescription">AbstractDescription</a> by extension): Descriptions entered as free-form text with optional (and potentially incomplete) markup referring to concepts (= char. tree nodes), characters, and states as defined in the terminology.</li><li><strong><a name="CodedDescription" id="CodedDescription">CodedDescription</a></strong> (<em>Complex type</em>, based on <a href="#AbstractDescription">AbstractDescription</a> by extension): Coded description data are highly controlled by the vocabulary and structures defined in the Terminology, using references to characters, states, modifiers, numerical values for measurements. They also support a limited amount of free-form text (in Notes or Annotation only). Separating data and terminology allows rearranging and refactoring the terminology, multilingual support through central terminology translations, and multiple hierarchical views. 

Coded descriptions must fulfill more rigorous consistency requirements than natural language descriptions and are more suitable for analysis. Furthermore, language-dependent annotations are minimized so that data can be easily reorganized and translated into multiple languages.

Note: Representation/MediaObject of entire description may contain media like images that are not specific to a character (else add them to character elements below).</li></ul><p>A special subtype of CodedDescription are original sampling data, which are organized into referrable SamplingEvent containers:</p><ul class="compact" compact="compact"><li><strong><a name="SamplingEventSet" id="SamplingEventSet">SamplingEventSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension): Collection of Sampling events</li><li><strong><a name="SamplingEvent" id="SamplingEvent">SamplingEvent</a></strong> (<em>Complex type</em>, based on <em>AbstractEvent</em> by extension): A container for a sample data, with repeated sampling units, each of which may record multiple characters that are observed together.</li><li><strong><a name="SamplingUnitDataSet" id="SamplingUnitDataSet">SamplingUnitDataSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension): (This is equivalent to the SummaryDataSet - the sample data structure has the intermediate event for which no equivalent exists in summary data!)</li><li><strong><a name="SamplingEventRef" id="SamplingEventRef">SamplingEventRef</a></strong> (<em>Complex type</em>, based on <em>AbstractLocalRef</em> by extension): Refers to a specific SampleData/SamplingEvent in a CodedDescription.</li></ul><hr/><p><strong>DESCRIPTIONS END</strong></p><hr/><p><strong>IDENTIFICATION KEYS START</strong></p><p>Stored identification keys (esp. manually designed as opposed to automatically generated) are stored in a separate section:</p><ul class="compact" compact="compact"><li><strong><a name="StoredKey" id="StoredKey">StoredKey</a></strong> (<em>Complex type</em>, based on <em>VersionedAbstractObject</em> by extension): Defines a stored identification key (dichotomous or multifurcating key) that has been digitized from printed publications or manually created to express expert knowledge that would not be available in dynamically created dichotomous keys (using Ratings from terminology and a 'find next best character' to minimize the average search tree).</li><li><strong><a name="StoredKey_LeadSeq" id="StoredKey_LeadSeq">StoredKey_LeadSeq</a></strong> (<em>Complex type</em>, based on <em>Seq</em> by extension)</li><li><strong><a name="StoredKeyAbstractNode" id="StoredKeyAbstractNode">StoredKeyAbstractNode</a></strong> (<em>Complex type</em>): Base type common to both lead and leaf nodes in a stored identification key.</li><li><strong><a name="StoredKeyNode" id="StoredKeyNode">StoredKeyNode</a></strong> (<em>Complex type</em>, based on <a href="#StoredKeyAbstractNode">StoredKeyAbstractNode</a> by extension): An inner node in a stored identification key, containing the lead statement to follow and optionally a next question answered by the following statements. The terminal nodes of the tree is defined by a separate Leaf type.</li><li><strong><a name="StoredKeyLeaf" id="StoredKeyLeaf">StoredKeyLeaf</a></strong> (<em>Complex type</em>, based on <a href="#StoredKeyAbstractNode">StoredKeyAbstractNode</a> by extension): A leaf (terminal node) in a stored identification key, containing the lead statement to follow plus the result of the key. Most frequently the result will point to a taxon/class name, but it may also point to a subkey, or create a 'reticulation' directly into this or another key.
Leaves have no id attribute and cannot be referenced.</li><li><strong><a name="StoredKeyRef" id="StoredKeyRef">StoredKeyRef</a></strong> (<em>Complex type</em>, based on <em>AbstractLocalRef</em> by extension): Refers to an entire stored identification key (e. g., if a key is referenced as a subkey from within another key)</li><li><strong><a name="StoredKeyNodeRef" id="StoredKeyNodeRef">StoredKeyNodeRef</a></strong> (<em>Complex type</em>, based on <em>AbstractLocalRef</em> by extension): Refers to a node in a stored key (e. g., for reticulating keys)</li></ul><hr/><p><strong>IDENTIFICATION KEYS END</strong></p><hr/><p><strong>Other basic types used by SDD (compare also the types used by UBIF)</strong></p><p>Character rating (equivalent to DELTA wheight, reliability, etc., but characters are scored taxon specific in descriptions rather than for all taxa)</p><ul class="compact" compact="compact"><li><strong><a name="Rating" id="Rating">Rating</a></strong> (<em>Complex type</em>): A rating of 1 (low) to 5 (high), with 3 as central value, the topic that is being rated, plus an optional indication whether inherited (= calculated based on related definitions) or defined directly.</li><li><strong><a name="RatingSet" id="RatingSet">RatingSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension): A collection of ratings to rate characters for conveniency, etc. This is especially relevant during interactive identification to rank the remaining characters for discriminative power and convenience.</li></ul><p>Special types for natural language wordings:</p><ul class="compact" compact="compact"><li><strong><a name="AbstractVocabularyBase" id="AbstractVocabularyBase">AbstractVocabularyBase</a></strong> (<em>Abstract Complex type</em>, based on <em>AbstractObject</em> by extension): Base of modifiers, stat. meas. elaborations, and categorical character states (both referrable concept and local character state definitions).

Any use of a modifier or character state in descriptions is a reference to an object derived from this class.</li></ul><ul class="compact" compact="compact"><li><strong><a name="NaturalLanguageGroup" id="NaturalLanguageGroup">NaturalLanguageGroup</a></strong> (<em>Element group</em>)</li></ul><ul class="compact" compact="compact"><li><strong><a name="NatLangPhraseString" id="NatLangPhraseString">NatLangPhraseString</a></strong> (<em>Complex type</em>, based on <em>LongStringL</em> by extension): A text element used to define wordings for natural language output. Currently the type only adds a role attribute. Further attributes may be required if the handling of leading and trailing blanks should not work in an interoperability context (e. g., attributes like BlankBefore / BlankAfter of type BooleanTripleState?).</li><li><strong><a name="NaturalLanguagePhraseSet" id="NaturalLanguagePhraseSet">NaturalLanguagePhraseSet</a></strong> (<em>Complex type</em>, based on <em>Set</em> by extension)</li></ul><hr/><p>(Generated on 23. May 2006 by DiversitySchemaTools Version 0.5. Copyright (c) G. Hagedorn 2006.)</p></body></html>